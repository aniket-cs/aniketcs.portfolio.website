import{g as Je,h as $e,m as Q}from"https://app.framerstatic.com/chunk-PFCTFETU.mjs";import{a as et,b as q}from"https://app.framerstatic.com/chunk-WKXRVQLW.mjs";import{a as Qe,b as Ze}from"https://app.framerstatic.com/chunk-B2X7EA3W.mjs";import{a as Y,b as Xe,c as Ye}from"https://app.framerstatic.com/chunk-3F65KONI.mjs";import{b as Ge,e as D}from"https://app.framerstatic.com/chunk-N7HPSFVJ.mjs";import{b as z}from"https://app.framerstatic.com/chunk-PY6P753Y.mjs";import{Pg as He,_ as pe,eg as X,ng as _e,od as qe,og as fe,pg as me,rg as ge,sg as k,ug as ve}from"https://app.framerstatic.com/chunk-V5GH6H6A.mjs";import{f as Ke}from"https://app.framerstatic.com/chunk-DI2RBLGE.mjs";import{xg as K}from"https://app.framerstatic.com/chunk-76LQFMAH.mjs";import{$l as ue,Gb as Me,Kb as Oe,Ki as Ve,Ya as xt,_l as Be,am as je,wa as Ue}from"https://app.framerstatic.com/chunk-6EMDOY3A.mjs";import{b as ze,c as We}from"https://app.framerstatic.com/chunk-AQVHSVOY.mjs";import{o as P}from"https://app.framerstatic.com/chunk-NSAK4CRU.mjs";import{c as Fe}from"https://app.framerstatic.com/chunk-FKVUZ4GS.mjs";import{a as Le,b as G}from"https://app.framerstatic.com/chunk-TBB27SWX.mjs";import{g as j}from"https://app.framerstatic.com/chunk-N5OTLEHJ.mjs";import{ba as Ae,ca as $,e as Ee,k as he,t as g}from"https://app.framerstatic.com/chunk-IFLV2SXW.mjs";import{a as u,b as ke}from"https://app.framerstatic.com/chunk-WNSBRACC.mjs";import{e as U,j as a}from"https://app.framerstatic.com/chunk-AHQIRSXG.mjs";var ye=g("app");function Ht(i){return i.treeReflectsDocument?It(i.tree):null}function It(i){return i.toJS()}function Jt(i){function e(t){let{__class:r,width:n,height:s,top:o,bottom:d,left:c,right:l}=t,{children:h}=t;return h?(h=h.map(e),{__class:r,width:n,height:s,top:o,bottom:d,left:c,right:l,children:h}):t.styledText?{__class:r,width:n,height:s,top:o,bottom:d,left:c,right:l,text:t.styledText.blocks.map(p=>p.text)}:{__class:r,width:n,height:s,top:o,bottom:d,left:c,right:l}}return e(i.tree.toJS().root)}function $t(i){let e,t=new XMLHttpRequest;t.open("GET",i.toString(),!1);try{t.send(),e=JSON.parse(t.responseText)}catch(r){ye.error(`Retrieving document \u201C${i}\u201D failed. (${r})`)}return Te(e)}function tt(i){j.isTest||i.forEach(e=>{ye.warn("[repaired]",e)})}function Te(i){let e=[];try{let t=Y(i,e);return tt(e),t}catch(t){throw tt(e),ye.warn("tree failed to verify:",t),t}}var Dt=g("DocumentLoader"),Se=g("remote:verify"),Z=class{constructor(e,t){this.data=e;this.settings=t;a(this,"parser");a(this,"canvasTreeVersion",0);this.parser=new Ze(e),this.canvasTreeVersion=this.parser.version}readFirstPage(){let e=!1,t=[];if(this.settings.activeNodeId&&(t.push(...this.parser.getPagesContainingId(this.settings.activeNodeId)),e=t.some(r=>$e(this.parser.getShallowPage(r)))),!e){let r=Je(this.parser.getShallowPages(),this.parser.getHomePageNodeID());t.push(r.id)}return Dt.debug("loadPartialDocument():",t),Ye(this.parser,t,this.settings.treeServices)}getScopesToLoad(){return this.parser.getPagesToLoad()}getParsedPageById(e){return this.parser.getParsedPageById(e)}buildPage(e){if(!e)return;let t=[],r=Se.isLoggingTraceMessages()?[]:void 0,n=X(e,this.parser.root.id,{extraChecksAndFixes:!0,errors:t,warnings:r});if(n&&Xe(n,t),t.length>0&&Se.warn("errors loading server tree: "+t.join(`
`)),r&&r.length>0&&Se.trace("warnings loading server tree: "+r.join(`
`)),!!n)return n}};var _=class extends Error{constructor(){super("cancelled"),this.name="CancelledError"}},ee=class{constructor(e){this.requestIdleCallback=e;a(this,"resumePromiseResolve");a(this,"resumePromise");a(this,"backgroundMode",!1);a(this,"done",!1);a(this,"firstError");a(this,"debugStepListener")}debugResumeOneStep(){this.resume(),this.pause()}currentMode(){return this.backgroundMode?"slow":"fast"}isDone(){return!!this.firstError||this.done}isSuccess(){return!this.firstError&&this.done}isCancelled(){return!!this.firstError&&this.firstError instanceof _}isError(){return!!this.firstError&&!(this.firstError instanceof _)}getError(){return this.firstError}cancel(){this.isDone()||(this.firstError=new _)}error(e){return this.isDone()||(this.firstError=e),e}pause(){this.firstError||this.resumePromise||(this.resumePromise=new Promise(e=>{this.resumePromiseResolve=e}))}resume(){let e=this.resumePromiseResolve;e&&(this.resumePromise=void 0,this.resumePromiseResolve=void 0,e())}isPaused(){return!!this.resumePromise}fast(){this.backgroundMode=!1}slow(){this.backgroundMode=!0}async run(e){u(!this.isDone(),"task is already done");try{await e()}catch(t){throw t instanceof Error?this.error(t):this.error(new Error(String(t??"Unknown Error")))}finally{this.done=!0}}async sleep(e){if(this.debugStepListener?.(),await Ee(e),this.resumePromise&&await this.resumePromise,this.debugStepListener?.(),this.resumePromise&&await this.resumePromise,this.firstError)throw this.firstError}async yield(){if(this.debugStepListener?.(),this.resumePromise?await this.resumePromise:this.backgroundMode?await new Promise(e=>{this.requestIdleCallback?this.requestIdleCallback(e):typeof requestIdleCallback=="function"?requestIdleCallback(e):setTimeout(e,0)}):await $(),this.resumePromise&&await this.resumePromise,this.debugStepListener?.(),this.resumePromise&&await this.resumePromise,this.firstError)throw this.firstError}};var m=g("DocumentLoader"),Nt=10,rt=1e3;function te(i){return i<1024*.75?`${Math.round(i)}b`:i<1024*1024*.75?`${(i/1024).toFixed(2)}kb`:`${(i/1024/1024).toFixed(2)}Mb`}function x(i){return i<200?`${i.toFixed(1)}ms`:i<20*1e3?`${(i/1e3).toFixed(3)}s`:`${Math.round(i/1e3)}s`}var nt=class extends Ge{constructor(t,r,n,s){super();this.cache=t;this.treeVersion=r;this.documentURL=n;this.settings=s;a(this,"scheduler");a(this,"retryCount",0);a(this,"scopesToLoad",new Set);a(this,"prioritizedScopeIds",new Set);a(this,"currentLoadingScope");a(this,"partialParser");a(this,"canvasTreeVersion",0);a(this,"documentSize",0);a(this,"loadedFirstScope",!1);a(this,"loadingDuration",0);a(this,"parsingDuration",0);a(this,"debugPaused",!1);a(this,"loadingScopesPaused",!1);a(this,"loadAllDataPriority",0);a(this,"updatePauseResumeState",()=>{if(!this.loadedFirstScope){this.scheduler.fast(),this.scheduler.resume();return}let t=this.loadAllDataPriority>0||this.prioritizedScopeIds.size>0,r=this.loadingScopesPaused||this.debugPaused;t?this.scheduler.fast():this.scheduler.slow(),t||!r||this.scopesToLoad.size<=0?this.scheduler.resume():this.scheduler.pause()});a(this,"tree");a(this,"loadCallbacksPerScope",new Map);a(this,"addedByDiff",new Set);a(this,"removedByDiff",new Set);this.scheduler=new ee(s.requestIdleCallback),m.debug("new:",this.treeVersion,this.documentURL)}pauseLoadingScopes(){this.loadingScopesPaused||(this.loadingScopesPaused=!0,m.debug("pauseLoadingScopes"),this.updatePauseResumeState())}resumeLoadingScopes(){this.loadingScopesPaused&&(this.loadingScopesPaused=!1,m.debug("resumeLoadingScopes"),this.updatePauseResumeState())}prioritizeLoadingAllData(t){let r="preload"in t&&t.preload;if(r&&P.isOn("debugEditWhileNeverLoadingRest"))return()=>{};let n=performance.now(),s=this.numberOfScopesToLoad();this.loadAllDataPriority=Math.max(1,this.loadAllDataPriority+1),m.debug("prioritizeLoadingScopes:",this.loadAllDataPriority),this.updatePauseResumeState();let o=r||"doNotTrack"in t&&t.doNotTrack,d=!1,c=o?void 0:this.afterAllDataLoaded(()=>{if(d)return;u("operationName"in t,"operationName is required");let h=performance.now()-n;Ke("fulltree_force_load",{operationName:t.operationName,durationMs:h,background:t.operationInBackground,shallowScopesCount:s})});return()=>{d||(d=!0,c?.(),this.stopPrioritizingLoadingAllData())}}stopPrioritizingLoadingAllData(){this.loadAllDataPriority-=1,m.debug("stopPrioritizingLoadingScopes:",this.loadAllDataPriority),this.updatePauseResumeState()}debugPause(){this.debugPaused||(this.debugPaused=!0,m.debug("debugPause"),this.updatePauseResumeState())}debugResume(){this.debugPaused&&(this.debugPaused=!1,m.debug("debugResume"),this.updatePauseResumeState())}isDebugPaused(){return this.debugPaused}afterAllDataLoaded(t){let r=this.scopesToLoad.size===0;if(t){if(r){let n=!1;return queueMicrotask(()=>{n||t()}),()=>{n=!0}}return this.once("loadedAllData",t),()=>{this.off("loadedAllData",t)}}return r?Promise.resolve():new Promise(n=>{this.once("loadedAllData",n)})}async start(){await this.scheduler.run(async()=>{m.debug("start"),D("parsingInit"),this.updatePauseResumeState();let t=performance.now(),r;if(await this.cache?.canUseSnapshot(this.treeVersion)){let s=await this.cache?.retrieveSnapshot();s&&(r=s.data)}if(r||(r=await this.loadData(),await this.cache?.storeSnapshot(r,this.treeVersion)),this.loadingDuration=performance.now()-t,await this.scheduler.yield(),!this.settings.partialParsing||!Qe(r))return this.parseFullDocumentSync(r);let n=await this.loadDocumentVersion(r);for(await this.scheduler.yield(),this.tree=await this.loadFirstTree(n),this.loadedFirstScope=!0,this.updatePauseResumeState(),await this.scheduler.yield(),D("parsingResume");this.hasNextScopeToLoad();)await this.loadNextScopeAsync(n),await this.scheduler.yield();await this.emitWrapped(()=>{u(this.tree,"tree must have been set"),this.tree.setService("loader",void 0),this.emit("loadedAllData")}),m.debug("done",te(this.documentSize),"loading:",x(this.loadingDuration),"parsing:",x(this.parsingDuration))})}async loadData(){if(this.settings.loadedData)return this.settings.loadedData;m.debug("Document in cache is not up to date. Tree version:",this.treeVersion);let t=this.settings.initData,r=t?.version===this.treeVersion,n=t?.prefetchPromise;if(t&&delete t.prefetchPromise,r&&n){m.debug("loadData: prefetch");let c=await n;n.then(h=>h.duration).then(h=>{D("dataLoad",h)}),await this.scheduler.yield();let l=await c.text;return await this.scheduler.yield(),c.status<200&&c.status>=300?this.handleErrorAndRetry(c.status,l):l}m.debug("loadData: fetch");let s;this.settings.refreshAccessToken&&(s=await this.settings.refreshAccessToken({}),await this.scheduler.yield());let o=await fetch(this.documentURL,s);await this.scheduler.yield();let d=await o.text();return await this.scheduler.yield(),D("dataLoad"),o.status<200||o.status>=300?this.handleErrorAndRetry(o.status,d):d}async handleErrorAndRetry(t,r){let n=!1;try{n=JSON.parse(r).retry}catch{}if(n&&this.retryCount<Nt)return m.debug("onErrorStatusLoaded, retry:",this.retryCount),await this.scheduler.sleep(this.retryCount*rt+Math.random()*rt),this.retryCount+=1,this.loadData();throw Error(n?"Too many retries":`Fetch Error: ${t} - ${r}`)}parseFullDocumentSync(t){let r=performance.now();this.documentSize=t.length;let n=JSON.parse(t);if(!Fe(n.version))throw Error("cannot read document version");if(this.canvasTreeVersion=n.version,m.debug("parseFullDocumentSync",this.canvasTreeVersion,te(this.documentSize),x(this.loadingDuration)),this.emit("loadedDocumentVersion",n.version),this.scheduler.isDone())return;let s=Te(n);this.emit("loadedSomeData",s,void 0),!this.scheduler.isDone()&&(this.emit("loadedAllData"),this.parsingDuration+=performance.now()-r,D("parsingFirstPage"),m.debug("done",te(this.documentSize),"loading:",x(this.loadingDuration),"parsing:",x(this.parsingDuration)))}hasLoadedScope(t){let r=this.scopesToLoad.has(t),n=this.currentLoadingScope?.id===t;return!r&&!n}numberOfScopesToLoad(){return this.scopesToLoad.size}prioritizeLoadingScope(t,r){let n,s;if(typeof r=="function")this.addScopeLoadCallback(t,r);else if(r&&"onLoaded"in r)this.addScopeLoadCallback(t,r.onLoaded),s=r;else{let o=Ae();n=o,this.addScopeLoadCallback(t,o.resolve),s=r}if(!(s?.preload&&P.isOn("debugEditWhileNeverLoadingRest")))return this.scopesToLoad.has(t)&&(this.prioritizedScopeIds.add(t),this.updatePauseResumeState(),this.addScopeLoadCallback(t,this.updatePauseResumeState)),n}nextScopeIdToLoad(){for(let r of this.prioritizedScopeIds)if(this.prioritizedScopeIds.delete(r),!!this.scopesToLoad.has(r))return this.scopesToLoad.delete(r),this.scheduler.fast(),r;let t=this.loadAllDataPriority>0;this.settings.loadInBackground&&!t?this.scheduler.slow():this.scheduler.fast();for(let r of this.scopesToLoad)return this.scopesToLoad.delete(r),r;throw Error("No next scope to load")}async loadDocumentVersion(t){this.documentSize=t.length;let r=performance.now(),n=new Z(t,this.settings);return this.canvasTreeVersion=n.canvasTreeVersion,this.parsingDuration+=performance.now()-r,m.debug("loadDocumentVersion",this.canvasTreeVersion,te(this.documentSize),x(this.loadingDuration)),await this.emitWrapped(()=>{if(this.scheduler.isDone())return;let s=performance.now();this.emit("loadedDocumentVersion",n.canvasTreeVersion),this.parsingDuration+=performance.now()-s}),this.partialParser=n,n}async loadFirstTree(t){let r=performance.now(),n=t.readFirstPage();this.scopesToLoad=t.getScopesToLoad();for(let d of this.scopesToLoad){let c=n.get(d);c&&(c.cache.isShallowLoad=!0)}this.parsingDuration+=performance.now()-r,m.debug("loadFirstTree",x(this.parsingDuration));let s=await this.cache?.getMergedTreeUpdates();s&&m.debug("Tree updates loaded from cache. Version:",s.version);let o=s?.changes;return await this.emitWrapped(()=>{if(this.scheduler.isDone())return;let d=performance.now();n.setService("loader",this),this.emit("loadedSomeData",n,o),D("parsingFirstPage"),this.parsingDuration+=performance.now()-d}),n}hasNextScopeToLoad(){return this.scopesToLoad.size>0}async loadNextScopeAsync(t){u(!this.currentLoadingScope,"already have a currently loading scope");let r=this.nextScopeIdToLoad();this.currentLoadingScope=new ne(r);let n=await this.currentLoadingScope.run(this.scheduler,t);m.debug("loadScopeAsync:",r,x(n.duration),"scheduler mode:",this.scheduler.currentMode()),n.hasNode()&&await this.emitWrapped(()=>{if(this.scheduler.isDone())return;let s=performance.now(),o=n.take();this.currentLoadingScope=void 0,o&&(this.emit("loadedScope",o),this.parsingDuration+=n.duration+performance.now()-s,this.signalScopeLoadCallbacks(o.id))})}loadScope(t){if(u(this.partialParser,"loadScope before the parser is available"),this.currentLoadingScope?.id===t){let n=this.currentLoadingScope.force(this.partialParser);return this.parsingDuration+=n.duration,this.currentLoadingScope=void 0,n.take()}if(this.prioritizedScopeIds.delete(t),!this.scopesToLoad.has(t))return;this.scopesToLoad.delete(t);let r=new ne(t).force(this.partialParser);return this.parsingDuration+=r.duration,m.debug("loadScope:",t,x(r.duration)),this.signalScopeLoadCallbacks(t),r.take()}addScopeLoadCallback(t,r){if(!r)return;if(this.hasLoadedScope(t)){setTimeout(r);return}let n=this.loadCallbacksPerScope.get(t)??[];n.push(r),this.loadCallbacksPerScope.set(t,n)}signalScopeLoadCallbacks(t){setTimeout(()=>{let r=this.loadCallbacksPerScope.get(t);if(r){for(let n of r)n();this.loadCallbacksPerScope.delete(t)}})}async emitWrapped(t){this.settings.asyncEventWrapper?(await this.scheduler.yield(),await this.settings.asyncEventWrapper(t)):(await this.scheduler.yield(),t())}resetTreeForRecovery(t){t.setService("loader",this);for(let r of this.scopesToLoad){let n=t.get(r);n&&(n.cache.isShallowLoad=!0)}this.tree=t}async nodeIdsToLoad(){let t=performance.now(),r=new Set;if(!this.partialParser)return r;let n=performance.now();for(let s of this.scopesToLoad){performance.now()-n>50&&(await $(),n=performance.now());let o=this.partialParser.getParsedPageById(s);st(r,o)}for(let s of this.addedByDiff)r.add(s);for(let s of this.removedByDiff)r.delete(s);return m.debug("nodeIdsToLoad",r.size,x(performance.now()-t)),r}addNodeChanges(t){for(let r of t){let n=r.id;r.added?(this.addedByDiff.add(n),this.removedByDiff.delete(n)):r.removed&&(this.addedByDiff.delete(n),this.removedByDiff.add(n))}}};function st(i,e){if(e&&(i.add(e.id),!!e.children))for(let t of e.children)st(i,t)}var re=class{constructor(e,t){this.node=e;this.duration=t}hasNode(){return!!this.node}take(){let e=this.node;return this.node=void 0,e}},ne=class{constructor(e){this.id=e;a(this,"data");a(this,"loadedScope")}async run(e,t){if(this.loadedScope)return this.loadedScope;let r=performance.now();this.data=t.getParsedPageById(this.id);let n=performance.now()-r;if(await e.yield(),this.loadedScope)return this.loadedScope;let s=performance.now(),o=t.buildPage(this.data);return o&&(o.cache.isShallowLoad=!1),this.loadedScope=new re(o,n+performance.now()-s),this.loadedScope}force(e){if(this.loadedScope)return this.loadedScope;let t=performance.now();this.data||(this.data=e.getParsedPageById(this.id));let r=e.buildPage(this.data);return r&&(r.cache.isShallowLoad=!1),this.loadedScope=new re(r,performance.now()-t),this.loadedScope}};var it=U(xt());var H=U(G());async function ot(i,e,t=1/0,r){r??=new Q(i,{silent:!0});let n=[],s=[],o=[];for(let c of e){if(o.length>=t){s.push(c);continue}if(!We.includes(c.type)){n.push(c);continue}let l=r.add(c);o.push(l)}return n.length>0&&z({type:"add",key:"importUploadImagesUnsupported",variant:"warning",text:(0,H.jsxs)("span",{className:K,children:["Skipped ",n.length," unsupported images"]}),duration:1e4}),s.length>0&&z({type:"add",key:"importUploadImagesSkipped",variant:"warning",text:(0,H.jsxs)("span",{className:K,children:["Skipped ",s.length," images over field limit"]}),duration:1e4}),Pt(r,o).catch(()=>{}),(await Promise.all(o)).filter(q)}async function Pt(i,e){let t="uploadEmbeddedImagesByUrl",r={type:"add",key:t,variant:"progress",icon:"image",duration:1/0,showCloseButton:"never"};for await(let{completed:s,started:o}of i.statusUpdates())z({...r,text:(0,H.jsxs)("span",{className:K,children:["Adding ",s," of ",o," images\u2026"]})});await Promise.allSettled(e);let{failed:n}=i.status;n>0&&z({type:"add",key:"importUploadImagesFailed",variant:"warning",text:(0,H.jsxs)("span",{className:K,children:["Failed to upload ",n," ",(0,it.default)("image",n)]}),duration:5e3}),z({type:"remove",key:t})}var at=g("ChooseFileService"),be=class{constructor(e,t,r){this.engine=e;this.assetService=t;this.filePickerRef=r;a(this,"assetUploader");this.assetUploader=new Q(this.engine)}async pickFile({allowedFileTypes:e,multiple:t}={}){let r=this.filePickerRef.current;if(!r)return null;let n=await r.show(e?.map(s=>`.${s}`),t);return n.isFiles()?n.value:null}async pickImage({allowedFileTypes:e=ze,multiple:t}={}){return this.pickFile({allowedFileTypes:e,multiple:t})}async pickAndUploadImage(e={}){try{let t=await this.pickImage(e);if(!t)return[];if(t.length===1){let r=await this.assetUploader.add(t[0]);if(!r)return[];if(await this.assetService.refresh().catch(he),q(r))return[r]}else return await ot(this.engine,t,e.maxUploads)}catch(t){at.warn("Failed to upload file:",t)}return[]}async pickAndUploadFile(e){try{let t=await this.pickFile(e);if(!t)return;let r=t[0];return r?await this.assetUploader.add(r):void 0}catch(t){at.warn("Failed to upload file:",t)}}async addImages(e){if(!e?.length)return[];let r=(await Promise.all(Array.from(e,n=>this.assetUploader.add(n)))).filter(q);return r.length===0||await this.engine.webAssetsService?.refresh().catch(he),r}},{service:Er,resolve:kt}=et();function Ar(i,e,t){kt(new be(i,e,t))}var Et=g("wantsNativeTextActions");function dt(i=document.activeElement){if(!(i instanceof HTMLElement))return!1;if(i.classList.contains("wantsNativeTextAction")||i instanceof HTMLIFrameElement)return!0;if(i instanceof HTMLInputElement)switch(i.type){case"date":case"datetime-local":case"email":case"month":case"number":case"password":case"search":case"tel":case"text":case"time":case"url":case"week":return!0;case"checkbox":case"color":case"file":case"image":case"radio":case"range":case"reset":case"submit":return!1;default:return Et.reportErrorOncePerMinute("Unhandled input type: "+i.type),!1}return i instanceof HTMLTextAreaElement||P.isOn("rightClickOnLinks")&&(i instanceof HTMLAnchorElement||i.closest("a"))?!0:i.isContentEditable}var E=U(Le());var ft=U(G());function Ce(i){return i.wantsActions?i.wantsActions():!0}function we(i,e,t){return i.wantsAction?i.wantsAction(e,t):!0}function lt(i,e){return i.optionsForAction?i.optionsForAction(e):void 0}var ht;(r=>{function i(n){return new t(n)}r.chain=i;function e(n,s){return n&&n instanceof t?n.actionToTargetMap[s]:n}r.functionTarget=e;class t{constructor(s){a(this,"actionToTargetMap",{});a(this,"wantedActions",[]);this.then(s)}then(s){this.wantedActions=this.wantedActions.concat(s.wantedActions);let o=this.actionToTargetMap,d=s.wantedActions;for(let c of d)o[c]=o[c]||s;return this}wantsAction(s,o){let d=this.actionToTargetMap[s];return!d||!Ce(d)?!1:we(d,s,o)}optionsForAction(s){let o=this.actionToTargetMap[s];if(o)return lt(o,s)}}})(ht||={});var F=class extends Event{constructor(){super(...arguments);a(this,"actionIdentifier");a(this,"actionArgument")}};a(F,"eventType","vekter-action-dispatch-event");var M=class extends Event{constructor(){super(...arguments);a(this,"invalidatedActions");a(this,"validatedActionStates");a(this,"validatedActionOptions")}};a(M,"eventType","vekter-action-validation-event");function jr({target:i,engine:e,children:t,style:r,global:n}){let s=(0,E.useRef)(null),o=(0,E.useCallback)(l=>{let h=l.actionIdentifier;if(!h)return;let p=ht.functionTarget(i,h);if(!p||!p.wantedActions.includes(h)||!Ce(p))return;let v=p[h];if(typeof v!="function")return;let b=we(p,h,l);if(!b||(l.preventDefault(),l.stopPropagation(),b!==!0))return;e.setEditReason(String(h));let f=v.bind(p);e.wrapHandler(f)(l.actionArgument)},[e,i]),d=(0,E.useCallback)(l=>{let{invalidatedActions:h,validatedActionStates:p,validatedActionOptions:v}=l;if(!(!h||!p||!v)&&i){for(let b of i.wantedActions)if(h.has(b)){h.delete(b);let f=Ce(i)?we(i,b,l):!1;if(p[b]=f,f===!0||f===!1){let y=lt(i,b);y&&(v[b]=y)}}h.size===0&&(l.preventDefault(),l.stopPropagation())}},[i]);(0,E.useEffect)(()=>{if(!s.current)return;let l=(n?document.documentElement:null)||s.current;return l.addEventListener(F.eventType,o),l.addEventListener(M.eventType,d),()=>{l.removeEventListener(F.eventType,o),l.removeEventListener(M.eventType,d)}},[n,o,d]);let c=(0,E.useCallback)(l=>{!dt(l.target)&&!j.isDebugBuild&&l.preventDefault()},[]);return(0,ft.jsx)("div",{ref:s,onContextMenu:c,style:r,children:t})}function zr(i,e){let t=document.activeElement;if(!t)throw Error("No active element for action dispatch");let r=new F(F.eventType,{bubbles:!0});return r.actionIdentifier=i,r.actionArgument=e,t.dispatchEvent(r)}function At(i){let e=document.activeElement;if(!e)throw Error("No active element for action validation");let t=new Set;for(let o of i)t.add(o);let r={},n={},s=new M(M.eventType,{bubbles:!0});return s.invalidatedActions=t,s.validatedActionStates=r,s.validatedActionOptions=n,e.dispatchEvent(s),{states:r,options:n}}var ut=[],pt=[];function Wr(i){ut.push(i)}function Kr(i){pt.push(i)}function qr(i){let e=i==="*"?Object.keys(se):[i];ut.forEach(n=>n());let{states:t,options:r}=At(e);Object.assign(se,t),Object.assign(ct,r);for(let n of e)se[n]=t[n]||(n==="undo"||n==="redo"||n==="delete"?"native":!1);return pt.forEach(n=>n()),{states:se,options:ct}}var se={},ct={};function mt(i){if(!i.children)return;let e=new Map;for(let t of i.children)Me(t)&&e.set(t.id,{master:t,replicas:new Map});for(let t of i.children){if(!Oe(t))continue;let r=e.get(t.replicaInfo.master);r&&r.replicas.set(t.id,t)}for(let{master:t,replicas:r}of e.values())Lt(t,r)}function Lt(i,e){for(let t of e.values()){let r=t.replicaInfo;u(r.master===i.id,"Replica must match master");let n=r.overrides;if(r.inheritsFrom){let p=e.get(r.inheritsFrom);p&&(n=Be(n,p.replicaInfo.overrides))}let s=n[i.id],o=t.duplicatedFrom;pe.copyToNode(t,i,s),t.duplicatedFrom=o;let d=!1;Ve(t)&&(d=!0,je(t,n,i),ue(i,t));let c=t.id,l=i.children;if(!l)return;let h=new Array(l.length);for(let p=0,v=l.length;p<v;p++)h[p]=gt(c,n,l[p],c,d);t.children=h}}function gt(i,e,t,r,n){let s=X({__class:t.__class,id:i+t.id,parentid:r});u(s,"Failed to create replica node");let o=e[t.id];if(pe.copyToNode(s,t,o),s.duplicatedFrom=null,n&&ue(t,s),t.children){let d=t.children,c=new Array(d.length);for(let l=0,h=d.length;l<h;l++)c[l]=gt(i,e,d[l],s.id,n);s.children=c}return s}var T=g("tree:timeline"),Re=class{constructor(e){this.nodeChangesBuffers=e;a(this,"changes",new Map);this.nodeChangesBuffers.add(this)}trackChange(e,t){let r=this.changes.get(e);if(r){t&&r.push(t);return}this.changes.set(e,t?[t]:[])}read(){let e=this.changes;return this.changes=new Map,e}clear(){this.changes=new Map}dispose(){this.nodeChangesBuffers.delete(this)}},O=class{constructor(e,t,r=[],n=!1){this.tree=e;this.changes=t;this.editReasons=r;this.wasRebase=n;a(this,"wasScopeInsert",!1);a(this,"version",0)}toDebugData(){return{version:this.version,changes:this.changes,editReasons:this.editReasons,wasScopeInsert:this.wasScopeInsert,wasRebase:this.wasRebase}}},xe=class{constructor(){a(this,"idToChanges",new Map)}getChanges(){return Array.from(this.idToChanges.values())}addChanges(e){if(e)for(let t of e){let r=this.idToChanges.get(t.id);r||(r={id:t.id,to:{}},this.idToChanges.set(t.id,r)),fe(r,t)}}},ie=class{constructor(e,t){a(this,"tree");a(this,"entries");a(this,"latestReversibleNodeChanges",null);a(this,"trimmed",0);a(this,"isPartialTree",!1);a(this,"isLoading",!1);a(this,"rollingDiff",null);a(this,"localChangesSentToRemote",0);a(this,"remoteTreeIndex",0);a(this,"inErrorRecovery",!1);a(this,"nodeChangesBuffers",new Set);a(this,"legacyMode",!1);a(this,"remoteTreeVersion",0);a(this,"recentEditReasons",[]);a(this,"flagsForNextCommit");a(this,"extraChangesForNextCommit");a(this,"resetTime",0);a(this,"epoch",0);this.reset(e,t)}get localTreeIndex(){return this.trimmed+this.entries.length-1}setFlagsForNextCommit(e){this.flagsForNextCommit=e}setExtraChangesForNextCommit(e){this.extraChangesForNextCommit=e}recordEditReasons(e){e&&this.recentEditReasons.push(e)}trackChange(e,t=null){for(let r of this.nodeChangesBuffers)r.trackChange(e,t)}getTreeForVersion(e){if(!this.isPartialTree&&!this.isLoading)return qe(this.entries,t=>t.version===e)?.tree}setRemoteTreeVersion(e){if(this.remoteTreeVersion=e,this.isPartialTree||this.isLoading)return;let t=this.getRemoteEntry();u(t,"remote tree is missing"),t.version=e}reset(e,t){if(this.resetTime=performance.now(),this.inErrorRecovery&&e===this.tree){T.debug("reset for error recovery..."),this.inErrorRecovery=!1,this.invalidateAllCursors(),this.clearNodeChangesReader();return}T.debug("reset with tree:",e.root.id,"size:",e.size()),this.tree=e,this.entries=[new O(e,t?.initialChanges??[],["load"])],this.recentEditReasons=[],this.flagsForNextCommit=void 0,this.extraChangesForNextCommit=void 0,this.latestReversibleNodeChanges=null,this.localChangesSentToRemote=0,this.trimmed=0,this.remoteTreeIndex=0,this.isPartialTree=!!t?.isPartialTree,this.isLoading=!!t?.isLoading,this.isLoading&&P.isOn("rollingDiff")&&(this.rollingDiff=new xe,this.rollingDiff.addChanges(t?.initialChanges)),this.invalidateAllCursors(),this.clearNodeChangesReader()}invalidateAllCursors(){this.epoch+=1}openNodeChangesReader(){return new Re(this.nodeChangesBuffers)}clearNodeChangesReader(){for(let e of this.nodeChangesBuffers)e.clear()}loadOneScope(e,t=!1){T.debug("loadOneScope:",e.id),u(this.isLoading,"Must be loading"),u(!e.cache.isShallowLoad,"Scope must not be shallow");let r=this.getRemoteEntry();u(r,"remote tree is missing");let n=this.tree.isViewOnly;r.tree.editClosed=!1,r.tree.isViewOnly=!1,r.tree.inEditor=!1,r.tree.makeLatest();let s=new Set,o=r.tree.root.children.findIndex(h=>h.id===e.id);if((e.__class==="WebPageNode"||e.__class==="SmartComponentNode")&&P.isOn("expandReplicasWithoutTree")){mt(e),r.tree=r.tree.commitWithLoadedScope(e);for(let h of e.walk())this.trackChange(h.id),s.add(h.id)}else r.tree.remove(e.id),r.tree.insertNode(e,r.tree.root.id,o);if(this.rollingDiff){let h=this.rollingDiff.getChanges();s.size>0?ge(h,s)&&k(r.tree,h):k(r.tree,h)}else{let h=0,p=s.size>0,v=this.getRemoteIndex();for(let b of this.entries){if(h>v)break;h++,!b.wasScopeInsert&&(p&&!ge(b.changes,s)||(p=!1,k(r.tree,b.changes)))}}o===-1?u(!r.tree.get(e.id),"Scope must have been deleted by remote diffs"):r.tree.loadReplicasAndCodeComponents(e);let d=r.tree.commit((h,p)=>{let v=h?.id??p?.id;v&&this.trackChange(v)});r.tree.inEditor=!0,d.inEditor=!0,this.remoteTreeIndex+=1,t||(this.latestReversibleNodeChanges=null);let c=this.entries.length-this.getRemoteIndex();u(c>=0,"computed rebase is off");let l;return c===0?l=this.addRemoteTreeWithChanges(d,[]):l=this.rebaseRemoteTreeWithChanges(d,[],c),l.wasScopeInsert=!0,this.legacyMode&&this.invalidateAllCursors(),d.isViewOnly=n,this.rollingDiff&&this.trimForShallowLoading(),this.tree}loadedAllScopes(){T.info("done loading, took:",Math.round((performance.now()-this.resetTime)/100)/10,"seconds"),u(this.isLoading,"Must be in loading mode"),this.isLoading=!1,this.rollingDiff=null;let e=this.getRemoteEntry();e&&(e.version=this.remoteTreeVersion,this.trimForShallowLoading())}getRemoteEntry(){let e=this.getRemoteIndex();return this.entries[e]}getRemoteIndex(){return this.remoteTreeIndex-this.trimmed}loadCompleteTree(e,t=0){T.debug("load complete tree:",this.tree.sizeAtStart(),"->",e.size(),"entries:",this.entries.length),u(this.trimmed===0,"cannot load complete tree while having local changes"),u(!e.hasUncommittedChanges(),"tree should be clean"),this.entries.forEach((o,d)=>{d>this.remoteTreeIndex||k(e,o.changes)}),e.hasUncommittedChanges()&&(e=e.commitDiffs());let r=[],n=this.tree;if(n.sizeAtStart()*2>e.size()){let o={};for(let d of e.root.walk()){let c=n.getNodeAtStart(d.id)||void 0,l=ve(c,d);l&&(o[l.id]=l),this.trackChange(d.id,l)}r=Object.values(o),T.debug("load complete tree, diff:",r.length)}else this.invalidateAllCursors(),T.debug("load complete tree, resending:",this.tree.size());this.remoteTreeIndex+=1,this.latestReversibleNodeChanges=null;let s=this.entries.length-this.remoteTreeIndex;return u(s>=0,"computed rebase is off"),e.lineage!==this.tree.lineage?(this.reset(e),this.setRemoteTreeVersion(t),this.tree):(s===0?this.addRemoteTreeWithChanges(e,r):this.rebaseRemoteTreeWithChanges(e,r,s),this.isPartialTree=!1,this.setRemoteTreeVersion(t),this.trim(),this.tree.forEachNode(o=>this.trackChange(o.id)),this.tree)}trim(){if(this.isPartialTree||this.isLoading)return;let e=0;this.remoteTreeIndex>0?e=this.getRemoteIndex()-100:e=this.localTreeIndex-this.trimmed-100,!(e<=75)&&(this.trimmed+=e,T.debug("trim",e,"new offset:",this.trimmed,"entries.length:",this.entries.length),this.entries.splice(0,e),u(this.remoteTreeIndex===0||this.getRemoteIndex()>=0,"must have some buffer before remoteTreeIndex"))}trimForShallowLoading(){if(this.isPartialTree)return;let e=this.getRemoteIndex()-3;e<=0||(this.trimmed+=e,T.debug("trim",e,"new offset:",this.trimmed,"entries.length:",this.entries.length,"after load"),this.entries.splice(0,e),u(this.remoteTreeIndex===0||this.getRemoteIndex()>=0,"must have some buffer before remoteTreeIndex"))}applyFlagsToChange(e){e&&this.flagsForNextCommit&&(this.flagsForNextCommit.ignoreInUndo&&(e.ignoreInUndo=!0),this.flagsForNextCommit.ignoreInCodeGeneration&&(e.ignoreInCodeGeneration=!0))}commitLocalTree(){let e=this.entries[this.entries.length-1];u(this.tree===e.tree,"tree out of sync");let t={};this.tree=this.tree.commit((n,s)=>{if(!n&&!s)return;let o=ve(n,s);if(this.applyFlagsToChange(o),this.trackChange(n?.id??s.id,o),o){if(o.to.parentid&&o.to.parentid!==o.from?.parentid){let c=this.tree.getScopeNodeAtStartFor(n),l=this.tree.getScopeNodeFor(s);c&&c?.id!==l?.id&&(o.previousScope=c.id)}t[o.id]=o}let d=[];_e(d,n,s);for(let c of d)this.applyFlagsToChange(c),this.trackChange(c.id,c),t[c.id]=c}),this.latestReversibleNodeChanges=Object.values(t);let r=this.latestReversibleNodeChanges;if(this.extraChangesForNextCommit){r=[...r];for(let n of this.extraChangesForNextCommit)this.applyFlagsToChange(n),this.trackChange(n.id,n),r.push(n)}return this.flagsForNextCommit=void 0,this.extraChangesForNextCommit=void 0,T.debug("commit local tree:",r.length,this.recentEditReasons),r.length>0?(u(e.tree!==this.tree,"must be a new tree"),e.tree.releaseMemory(),this.entries.push(new O(this.tree,r,this.recentEditReasons)),this.trim()):this.tree!==e.tree&&(e.tree.releaseMemory(),e.tree=this.tree),this.recentEditReasons=[],u(this.tree===this.entries[this.entries.length-1].tree),this.tree}getLatestChangesForUndo(){return this.latestReversibleNodeChanges}getChangeTrackingCursor(){let e=this.remoteTreeIndex,t=this.localTreeIndex;return{remoteTree:e,localTree:t,timeline:this,tree:this.tree,epoch:this.epoch}}invalidatedByLoadCompletedDocument(e){return!(!e||this.trimmed>0||e.timeline!==this||e.epoch+1!==this.epoch||e.remoteTree+1!==this.remoteTreeIndex)}fetchForwardChanges(e){if(!e||e.epoch!==this.epoch||e.tree.lineage!==this.tree.lineage||e.tree.root.id!==this.tree.root.id||e.timeline!==this||e.localTree>0&&e.localTree<=this.trimmed||e.remoteTree>0&&e.remoteTree<=this.trimmed||this.remoteTreeIndex>0&&this.trimmed>0&&e.remoteTree===0)return;let t=e.localTree;if(this.remoteTreeIndex>0)for(t=e.remoteTree-1;t<e.localTree&&!this.entries[t+1-this.trimmed]?.wasRebase;)t+=1;u(t-this.trimmed>=0,"buffer cut too close to remoteTree"),u(t<=e.localTree,"startIndex incorrectly calculated");let r=this.localTreeIndex;u(t<=r,"bad change tracking cursor");let n=e.tree;return e.remoteTree=this.remoteTreeIndex,e.localTree=r,e.tree=this.tree,this.computeForwardChanges(t,r,n)}computeForwardChanges(e,t,r){if(e>=t)return[];let n={};for(let o=e+1;o<=t;o++){let d=this.entries[o-this.trimmed];for(let c of d.changes){let l=c.id,h=n[l];h||(h=n[l]={id:l,to:{}});let p=h.added;fe(h,c),!r&&p&&h.removed&&delete n[l]}}let s=r??this.entries[e-this.trimmed].tree;return Object.values(n).filter(o=>{if(o.removed)return o.to={},!0;let d=s.getNodeAtStart(o.id);if(d)for(let[p,v]of Object.entries(o.to))Ue(d[p],v)&&delete o.to[p];if(o.added||Object.keys(o.to).length>0)return!0;let c=o.toChildren;if(!c)return!1;if(!d)return!0;s.beginAllowPartialScopeAccess();let l=d.children;if(s.endAllowPartialScopeAccess(),!l)return!0;let h=l.length;if(h!==c.length)return!0;for(let p=0;p<h;p++)if(l[p].id!==c[p])return!0;return!1})}getUnconfirmedChangeCount(){return this.localTreeIndex-this.remoteTreeIndex}hasChangesForRemote(){let e=this.remoteTreeIndex+this.localChangesSentToRemote,t=this.localTreeIndex;return u(e<=t,"inconsistency in getting local changes to send"),e<t}hasOnlyEmptyChangesForRemote(){let e=this.remoteTreeIndex+this.localChangesSentToRemote,t=this.localTreeIndex;return e>=t?!0:this.computeForwardChanges(e,t).length===0}getEditReasons(e,t){let r=[],n="";for(let s=e+1;s<=t;s++){let o=this.entries[s-this.trimmed].editReasons;for(let d of o)d&&n!==d&&(n=d,r.push(d))}return r.join(" ")}getForwardChangesForRemote(){let e=this.remoteTreeIndex+this.localChangesSentToRemote,t=this.localTreeIndex;u(e<t,"inconsistency in getting local changes to send");let r=this.computeForwardChanges(e,t),n=t-e;this.localChangesSentToRemote+=n;let s=this.getEditReasons(e,t);return{changes:r,count:n,reasons:s}}confirmLocalChangesByRemote(e,t=0){if(u(e>=1,"cannot confirm less than one change"),u(this.localChangesSentToRemote>=e,"cannot confirm local changes that have not been sent"),u(this.remoteTreeIndex<this.localTreeIndex,"must have unconfirmed local changes"),this.rollingDiff)for(let r=1;r<=e;r++)this.rollingDiff.addChanges(this.entries[this.remoteTreeIndex+r]?.changes);return this.localChangesSentToRemote-=e,this.remoteTreeIndex+=e,this.setRemoteTreeVersion(t),this.tree}insertRemoteChanges(e,t=0){T.debug("insertRemoteChanges:",e.length),u(this.tree===this.entries[this.entries.length-1].tree,"tree out of sync"),u(this.remoteTreeIndex<=this.localTreeIndex,"remote tree too far ahead"),this.rollingDiff&&this.rollingDiff.addChanges(e);let r=this.getRemoteEntry();u(r,"remote tree is missing");let n=this.tree.isViewOnly;r.tree.editClosed=!1,r.tree.isViewOnly=!1,r.tree.makeLatest(),r.tree.beginAllowPartialScopeAccess(),k(r.tree,e);let s=r.tree.commitDiffs();for(let d of e)this.trackChange(d.id,d);for(let d of r.tree.getNodesChangedByCommit())this.trackChange(d.id);this.remoteTreeIndex+=1,this.latestReversibleNodeChanges=null;let o=this.entries.length-this.getRemoteIndex();return u(o>=0,"computed rebase is off"),o===0?this.addRemoteTreeWithChanges(s,e):this.rebaseRemoteTreeWithChanges(s,e,o),this.trim(),this.setRemoteTreeVersion(t),r.tree.endAllowPartialScopeAccess(),s.isViewOnly=n,this.tree}addRemoteTreeWithChanges(e,t){T.trace("addRemoteTreeWithChanges:",t.length),u(e.lineage===this.entries[this.entries.length-1].tree.lineage,"Trees must belong to the same line."),u(!e.hasUncommittedChanges(),"Tree cannot have uncommitted changes.");let r=this.entries[this.entries.length-1];r.tree!==e&&r.tree.releaseMemory();let n=new O(e,t);return this.entries.push(n),this.tree=e,n}rebaseRemoteTreeWithChanges(e,t,r){T.debug("rebaseRemoteTreeWithChanges:",r,"changes:",t.length),u(e.lineage===this.entries[this.entries.length-1].tree.lineage,"Trees must belong to the same line."),u(!e.hasUncommittedChanges(),"Tree cannot have uncommitted changes."),u(this.entries.length>=r,"rebase",r,"> commits",this.entries.length);let n=this.entries.length,s=this.entries.splice(n-r,r);u(s.length===r,"must have",r,"entries to process");let o=new O(e,t,[],!0);this.entries.push(o);let d=e;for(let c=0;c<r;c++){let l=s[c];k(e,l.changes),e=e.commitDiffs();for(let h of l.changes)this.trackChange(h.id,h);for(let h of d.getNodesChangedByCommit())this.trackChange(h.id);this.entries.push(new O(e,l.changes,l.editReasons,l.wasRebase)),e!==d&&(d.releaseMemory(),d=e)}return this.tree=e,o}debugOverwriteCurrentTree(e){T.debug("recover with tree:",e.root.id),this.tree=e,this.entries[this.entries.length-1].tree=e}resetTreesForRecovery(){T.info("reset trees for recovery, remote:",this.remoteTreeIndex,"local:",this.localTreeIndex,"changes already sent:",this.localChangesSentToRemote);let e=this.getRemoteIndex(),t=this.entries[e].tree;u(t,"unable to get remote tree");let r=t.getService("loader"),n=[];t=Y(JSON.parse(JSON.stringify(t.toJS())),n),r&&(r.resetTreeForRecovery(t),u(t.getService("loader")===r,"tree must have the same loader")),n.length>0&&T.warn("[recovery] encountered errors while reloading the tree:",n),this.entries[e].tree=t,this.entries.length=1+e+this.localChangesSentToRemote;let s=t;for(e+=1;e<this.entries.length;e++){let o=this.entries[e];k(t,o.changes),t=t.commitDiffs(),o.tree=t,t!==s&&(s.releaseMemory(),s=t)}return this.inErrorRecovery=!0,this.tree=t,t}saveTimelineDataForRecovery(){if(window.localStorage)try{let e=`debugTimelineAtRecovery-${Math.floor(Math.random()*100)}`,t={date:new Date().toString(),entries:this.entries.map(r=>r.toDebugData())};window.localStorage.setItem(e,JSON.stringify(t))}catch(e){T.warn("failed to store timeline in localStorage:",e)}}};var S=U(Le());var Ut=0,oe=class{constructor(){a(this,"id",++Ut);a(this,"currentRtt",NaN);a(this,"rtts",[]);a(this,"rttIndex",0);a(this,"pending",Array.from(Array(128),()=>({type:"",time:0})));a(this,"start",0);a(this,"end",0);a(this,"overflow",0);a(this,"lastSendTime",0);a(this,"bytesSent",0);a(this,"bytesReceived",0)}read(){let{bytesSent:e,bytesReceived:t,id:r}=this;return this.bytesSent=0,this.bytesReceived=0,[e,t,this.rtt(),r]}computeRtt(){let e=this.rtts.length;if(e===0){this.currentRtt=NaN;return}let t=0;for(let r of this.rtts)t+=r;this.currentRtt=t/e}lastSend(){return this.lastSendTime}rtt(){return Number.isNaN(this.currentRtt)&&this.computeRtt(),Math.max(this.currentRtt||0,this.pendingRtt())}pendingRtt(){return this.start===this.end?0:performance.now()-this.pending[this.start].time}pendingCount(e){if(!e)return this.start>this.end?128-this.start+this.end:this.end-this.start;let t=0;for(let r=this.start;r!==this.end;r=r+1&127)this.pending[r].type===e&&t++;return t}sent(e,t){this.bytesSent+=t.length,this.end===(this.start===0?127:this.start-1)&&(this.start=this.start+1&127,this.overflow++);let r=this.pending[this.end];r.type=e,r.time=performance.now(),this.end=this.end+1&127,this.lastSendTime=r.time}received(e){this.bytesReceived+=e.length}acked(){if(this.start===this.end){console.warn("Called SocketStats.acked() with empty buffer");return}if(this.overflow>0){this.overflow--;return}let e=this.pending[this.start],t=performance.now()-e.time;this.rtts.length<32?this.rtts.push(t):(this.rtts[this.rttIndex]=t,this.rttIndex=this.rttIndex+1&31),this.start=this.start+1&127,this.currentRtt=NaN}};var N=g("remote:socket"),Ft=16;function Mt(i){switch(i){case"AccessDenied":case"ClientNeedsUpdate":case"ClientTooNew":case"DocumentNotFound":case"UnsupportedSchema":case"UnknownPermanentError":case"ClientSidePermanentError":return!1;case"ReconnectToNewServer":case"UnknownRecoverableError":case"ClientSideRecoverableError":return!0;default:return ke(i)}}function vn({url:i,documentConnection:e,tunnel:t=null}){let r=(0,S.useRef)(null),n=(0,S.useRef)(!0),s=(0,S.useRef)({onConnect:new Set,onDisconnect:new Set,onMessage:new Set}),o=(0,S.useRef)(i),d=(0,S.useRef)(!0),c=(0,S.useRef)(void 0);function l(){c.current!==void 0&&(window.clearTimeout(c.current),c.current=void 0)}let h=(0,S.useCallback)(()=>{d.current=!1;let f=r.current;f&&f.ws.readyState<WebSocket.CLOSING&&(f.clientClosed=!0,f.ws.close())},[]),p=(0,S.useCallback)(()=>{if(l(),!d.current||r.current)return;function f(C){c.current===void 0&&(c.current=window.setTimeout(()=>{c.current=void 0,navigator.onLine&&!document.hidden&&p()},C))}let y=new URL(o.current);if(y.searchParams.set("v",Ft.toString()),y.searchParams.set("tunnel",t||""),e.treeSchema<=0)return;y.searchParams.set("treeSchema",e.treeSchema.toString()),y.searchParams.set("treeVersion",e.treeVersion.toString()),N.debug("connecting to",y.href);let wt=performance.now(),B=new WebSocket(y.href),L=new oe,ce={ws:B,stats:L,clientClosed:!1};e.setSocketStats(L);let J=0;B.addEventListener("open",()=>{N.debug("open"),J=window.setInterval(()=>{if(performance.now()-L.lastSend()<1e3||L.pendingCount("ping")>1||B.readyState!==WebSocket.OPEN)return;let C="ping {}";B.send(C),L.sent("ping",C)},1e3);for(let C of s.current.onConnect)try{C(n.current)}catch(w){N.warn("Error in onConnect handler:",w)}n.current=!1}),B.addEventListener("close",C=>{let w=Vt(C);if(N.debug("close:",w,"clientClosed:",ce.clientClosed,C),J!==0&&(clearInterval(J),J=0),r.current===ce){Mt(w)||(d.current=!1);for(let R of s.current.onDisconnect)try{R(w)}catch(le){N.warn("Error in onDisconnect handler:",le)}if(r.current=null,d.current){let R=1e3;w==="ReconnectToNewServer"?R=50:performance.now()-wt<5e3&&(R=5e3),f(R)}}}),B.addEventListener("message",C=>{try{let w=C.data;L.received(w);let R=Bt(w);if(R.type==="ack"){L.acked();return}else R.type==="redirect"&&(o.current=R.value.url);for(let le of s.current.onMessage)try{le(R)}catch(Rt){N.warn("Error in onMessage handler:",Rt)}}catch(w){N.warn("Error receiving:",w)}}),r.current=ce},[e]);(0,S.useEffect)(()=>{p()},[p]);let v=(0,S.useCallback)(({online:f,visible:y})=>{f&&y?p():l()},[p]);return Ot(v),(0,S.useMemo)(()=>({getSocketStats(){return r.current?.stats},connect(){d.current=!0,p()},disconnect(){h()},onConnect(f){return s.current.onConnect.add(f),()=>{s.current.onConnect.delete(f)}},onDisconnect(f){return s.current.onDisconnect.add(f),()=>{s.current.onDisconnect.delete(f)}},onMessage(f){return s.current.onMessage.add(f),()=>{s.current.onMessage.delete(f)}},send(f){if(!r.current||r.current.ws.readyState!==1){f.type!=="state"&&N.warn("Dropping",f.type,"message.");return}try{let y=`${f.type} ${JSON.stringify(f.value)}`;r.current.ws.send(y),r.current.stats.sent(f.type,y)}catch(y){N.warn("Error sending",f.type,"message:",y)}}}),[p,h])}function Ot(i){(0,S.useEffect)(()=>{document.addEventListener("visibilitychange",e),window.addEventListener("online",e),window.addEventListener("offline",e);function e(){i({online:navigator.onLine,visible:!document.hidden})}return()=>{document.removeEventListener("visibilitychange",e),window.removeEventListener("online",e),window.removeEventListener("offline",e)}},[i])}function Vt(i){switch(i.reason){case"ERR_RECONNECT_TO_NEW_SERVER":return"ReconnectToNewServer";case"ERR_ACCESS_DENIED":return"AccessDenied";case"ERR_CLIENT_NEEDS_UPDATE":return"ClientNeedsUpdate";case"ERR_DOCUMENT_NOT_FOUND":return"DocumentNotFound";case"ERR_UNSUPPORTED_SCHEMA_VERSION":return"UnsupportedSchema";case"ERR_INVALID_OPERATION":return"ClientSidePermanentError";case"ERR_UNKNOWN":return"UnknownPermanentError"}return i.code===1011?"ClientNeedsUpdate":"UnknownRecoverableError"}function Bt(i){let e=i.indexOf(" "),t=i.indexOf(" ",e+1);u(e>=0&&t>=0,"Invalid data");let r=i.substring(0,e),n=i.substring(e+1,t),s=i.substring(t+1),o=JSON.parse(s);return{id:r,type:n,value:o}}var Ie=class i{constructor(e){this.indices=e}index(e,t){return new i({...this.indices,[e]:t})}};function de(){return new Ie({})}function A(i){return new Promise((e,t)=>{i.onsuccess=r=>{e(r.target.result)},i.onerror=r=>{t(r.target.error)}})}var W=class{constructor(e,t){this.cursorBackend=e;this.cursorKey=t}[Symbol.asyncIterator](){let e=this.cursorBackend.openCursor(this.cursorKey);return{next(){return new Promise(t=>{e.onsuccess=r=>{let n=r.target.result;n?(n.continue(),t({done:!1,value:n.value})):t({done:!0,value:void 0})}})},return(){return Promise.resolve({done:!0,value:void 0})}}}},De=class extends W{constructor(t){super(t);this.index=t}count(t){return A(this.index.count(t))}getAll(t){return A(this.index.getAll(t))}delete(t){let r=this.index.openCursor(t);return new Promise((s,o)=>{r.onsuccess=d=>{let c=d.target.result;c?(c.delete(),c.continue()):s()},r.onerror=d=>{o(d.target.error)}})}getAllKeys(t){return A(this.index.getAllKeys(t))}cursor(t){return new W(this.index,t)}},Ne=class extends W{constructor(t){super(t);this.store=t}count(t){return A(this.store.count(t))}get(t){return A(this.store.get(t))}put(t,r){return A(this.store.put(t,r))}delete(t){return A(this.store.delete(t))}getAll(t){return A(this.store.getAll(t))}index(t){return new De(this.store.index(t))}cursor(t){return new W(this.store,t)}},Pe=class{constructor(e){this.transaction=e}store(e){return new Ne(this.transaction.objectStore(e))}},ae=class i{constructor(e){this.db=e}static open(e){let t=window.indexedDB.open(e.name,e.version);return new Promise((r,n)=>{t.onsuccess=s=>{r(new i(s.target.result))},t.onerror=s=>n(s.target.error),t.onupgradeneeded=s=>{let o=s.target.result,d=s.target.transaction;try{for(let l of o.objectStoreNames)o.deleteObjectStore(l);let c;for(c in e.stores){let l=e.stores[c],h=o.createObjectStore(c),p;for(p in l.indices){let v=l.indices[p];h.createIndex(p,v,{unique:!1})}}}catch(c){d.abort(),n(c)}}})}static destroy(e){let t=window.indexedDB.deleteDatabase(e);return new Promise((r,n)=>{t.onsuccess=()=>r(),t.onerror=()=>n("Cannot destroy db"),t.onblocked=()=>n("Request is blocked")})}tx(e,t){let r=this.db.transaction(e,t);return new Pe(r)}close(){this.db.close()}};var V=g("DocumentCache"),jt={name:"FramerProjectCache",version:4,stores:{snapshots:de().index("id","project"),treeUpdates:de().index("id",["project","version"]).index("project","project").index("version","version"),versions:de().index("id","project")}},vt=class{constructor(e,t=50){this.id=e;this.mergeThreshold=t;a(this,"db");this.db=ae.open(jt)}async close(){(await this.db).close()}async storeSnapshot(e,t){try{let n=(await this.db).tx(["snapshots","treeUpdates","versions"],"readwrite");await n.store("snapshots").delete(this.id),await n.store("versions").delete(this.id),await n.store("treeUpdates").index("project").delete(this.id),await n.store("snapshots").put({project:this.id,data:e,version:t},this.id),await n.store("versions").put({project:this.id,version:t},this.id)}catch(r){V.reportError(r)}}async storeTreeUpdate(e){try{let r=(await this.db).tx(["treeUpdates","versions"],"readwrite"),n=r.store("treeUpdates"),s=r.store("versions");await n.put({project:this.id,changes:e.changes,version:e.version},[this.id,e.version]);let o=0,d=0;for await(let c of n.index("project").cursor(this.id)){if(o!==0&&c.version-o>1)break;o=c.version,d+=1}if(d>=this.mergeThreshold){let c=IDBKeyRange.bound([this.id,0],[this.id,o]),l=await n.getAll(c);await n.delete(c),await n.put({changes:me(l),project:this.id,version:o},[this.id,o])}await s.put({version:o,project:this.id},this.id)}catch(t){V.reportError(t)}}async getMergedTreeUpdates(){try{let t=(await this.db).tx(["treeUpdates","versions"],"readonly"),r=t.store("treeUpdates"),s=await t.store("versions").get(this.id).then(c=>c?.version);if(!s)return;let o=IDBKeyRange.bound([this.id,0],[this.id,s]),d=await r.getAll(o);return{changes:me(d),project:this.id,version:s}}catch(e){V.reportError(e);return}}async retrieveSnapshot(){try{return await(await this.db).tx(["snapshots"],"readonly").store("snapshots").get(this.id)}catch(e){V.reportError(e);return}}async canUseSnapshot(e){try{let r=(await this.db).tx(["versions","snapshots"],"readonly");if(await r.store("snapshots").count(this.id)===0)return!1;let n=await r.store("versions").get(this.id);return n?.version!==void 0&&n.version>=e}catch(t){return V.reportError(t),!1}}async retrieveVersion(){try{return await(await this.db).tx(["versions"],"readonly").store("versions").get(this.id).then(t=>t?.version)}catch(e){V.reportError(e);return}}async getTreeUpdates(){try{return await(await this.db).tx(["treeUpdates"],"readonly").store("treeUpdates").index("project").getAll(this.id)}catch(e){return V.reportError(e),[]}}};function yt(i){return typeof i=="object"&&i!==null&&"next"in i}function Tt(i){return yt(i)&&"session"in i}function St(i){return yt(i)&&"changes"in i&&Array.isArray(i.changes)}var I=g("remote:sync"),bt=Math.pow(2,52);function Ln(i){let{session:e,seq:t,count:r,reasons:n,changes:s}=i;return{session:e,seq:t,changes:s,count:r,reasons:n}}function zt(i,e){return{...i,next:e}}var Ct=class{constructor(e=He.createEmpty(),t=0,r){a(this,"session",Math.floor(Math.random()*bt));a(this,"seq",0);a(this,"treeVersion",0);a(this,"updatesSeen",0);a(this,"init",0);a(this,"expectingInitialUpdates",0);a(this,"timeline");a(this,"localUpdatesInFlight",[]);a(this,"localUpdatesAtInit",[]);a(this,"hasError",!1);a(this,"waitingForTree",!1);r?this.timeline=r:this.timeline=new ie(e),this.setTree(e,t)}get waitingForInitialUpdates(){return this.expectingInitialUpdates>this.updatesSeen}get isLoading(){return this.waitingForTree||this.waitingForInitialUpdates}get isReady(){return!(this.hasError||this.waitingForTree||this.waitingForInitialUpdates)}get tree(){return this.timeline.tree}commitAndCreateUpdate(e=0){u(j.isTest),this.timeline.commitLocalTree();let t=this.createUpdateToSend();return t?zt(t,e):null}error(e){return this.hasError=!0,Error(e)}verify(e,t){let r=this.timeline.getTreeForVersion(e);if(!r)return I.info("verify: unable to find tree with version",e),!0;let n=r.computeTreeHash();if(n!==t){if(I.warn("verify: failed",n,"!==",t),t===0)return!0;I.reportError("Tree verification failed",{localHash:n,serverHash:t,treeVersion:e,treeSize:r.size()})}else I.debug("verify: passed; hash:",t);return n===t}setTree(e,t,r){I.info("setTree",t),this.timeline.reset(e,r),r?.isPartialTree||this.timeline.setRemoteTreeVersion(t),this.treeVersion=t,this.waitingForTree=!1,this.hasError=!1,this.localUpdatesInFlight=[]}resetSession(){this.treeVersion=0,this.session=Math.floor(Math.random()*bt),this.localUpdatesInFlight=[],this.localUpdatesAtInit=[]}debugResetSessionAndTree(e){this.resetSession(),this.setTree(e,0)}loadCompleteTree(e){this.timeline.loadCompleteTree(e,this.treeVersion)}createUpdateToSend(){if(!this.isReady)throw Error("cannot create updates while not ready");if(!this.timeline.hasChangesForRemote())return null;let{changes:e,count:t,reasons:r}=this.timeline.getForwardChangesForRemote(),n=++this.seq,s={session:this.session,seq:n,changes:e,count:t,reasons:r,confirmed:!1};return this.localUpdatesInFlight.push(s),s}handleInit(e,t,r,n){this.init+=1,this.init===1&&D("wsTreeInitMessages"),I.info("init",this.init,{treeVersion:e,initialUpdates:t,localTreeVersion:this.treeVersion}),I.debug("init updates:",{seen:this.updatesSeen,inFlight:this.localUpdatesInFlight.length,previous:this.localUpdatesAtInit.length}),this.hasError=!1,this.expectingInitialUpdates=t,this.updatesSeen=0,this.localUpdatesAtInit=this.localUpdatesInFlight.slice(),(this.treeVersion!==e||this.waitingForTree)&&(this.waitingForTree=!0,n(r,e))}handleRemoteUpdate(e){if(this.hasError||this.waitingForTree)return;u(typeof e.next=="number","must be a valid tree update");let t=e.next;if(I.trace("this:",this.session,this.seq,"at:",this.treeVersion,"update:",e),t!==this.treeVersion+1){if(t<=this.treeVersion){I.debug("ignoring old update:",t," <= ",this.treeVersion);return}throw this.error("missing update: "+this.treeVersion+" + 1 != "+t)}if(this.updatesSeen+=1,this.treeVersion=t,Tt(e)&&e.session===this.session){let r=this.localUpdatesInFlight[0];if(r?.seq===e.seq)this.localUpdatesInFlight.shift(),this.timeline.confirmLocalChangesByRemote(r.count,t),r.confirmed=!0;else{let n=this.localUpdatesAtInit.find(s=>s.seq===e.seq);if(n)this.timeline.insertRemoteChanges(n.changes,t),n.confirmed=!0;else{let s=this.localUpdatesInFlight.findIndex(d=>d.seq===e.seq),o=s===-1?"unknown local update: "+e.seq+" != "+r?.seq:"missing local update: "+e.seq+" != "+r?.seq+", is index: "+s;throw this.error(o)}}}else St(e)?e.changes.length>0&&this.timeline.insertRemoteChanges(e.changes,t):I.reportErrorOncePerMinute(new Error("Unknown remote update"),{update:e})}};export{ot as a,Pt as b,Er as c,Ar as d,dt as e,ht as f,jr as g,zr as h,Wr as i,Kr as j,qr as k,ie as l,oe as m,Ft as n,Mt as o,vn as p,Vt as q,Bt as r,vt as s,Tt as t,St as u,Ht as v,Jt as w,$t as x,Te as y,nt as z,Ln as A,Ct as B};
//# sourceMappingURL=https://app.framerstatic.com/chunk-FORUFGZA.mjs.map
